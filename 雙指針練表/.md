### 關於練表倒數第 N 個節點

```C++
ListNode* findFromEnd(ListNode* head,int n){
    ListNode* p1 = head;
    for(int i=0;i<n;i++){
        p1 = p1->next;
    }
    ListNode* p2 = head;
    while(p1 != nullptr){
        p1 = p1->next;
        p2 = p2->next;
    }
    return p2;
}
```

### 關於獲得中點

- 因為沒辦法直接獲得 n(長度),所以使用快慢指針
  - 設定 fast 和 slow,flast 一次走 2 步,slow 一次走 1 步,當 fast 走對最後時,slow 剛好會在中間

### 關於獲得起點位置

- 假設 slow 走了 k 步,fast 一定走了 2k 步,他們相遇的位置距離起點一定為 n-k 步(全部-走的步)
- 因此將其中一個點放回練表的 head 後,再讓他們用相同速度走 k 步,下次再遇到的位置就會是起點

### 相交練表

- 記住一段話：
  - 你走過的路，他也走過，這成全了你們再一起的理由。最後之所以能給出答案，是因為你變成了他，他也變成了你
  - 最後的你們都會是一樣的
  - AC 或許也不是那麼重要了
